.program cppm_decoder

.define public NUM_CHANNELS 9
.define public CLOCKS_PER_COUNT 5

init:
  pull block ; Load OSR with max period duration
  set y, 0 ; no channels to flush
  set x, 0 ; frame status unknown, wait for sync
  jmp flush_channels

after_sync:
  set x, NUM_CHANNELS ; frame okay

.wrap_target
flush_channels:
  jmp !y flush_channels_done ; no more channels to flush
  jmp y-- nojmp_flush_channels
nojmp_flush_channels:
  mov isr, null ; load 0 into ISR and push to FIFO
  push block
  jmp flush_channels
flush_channels_done:
  mov y, x ; next frame will capture 0 or NUM_CHANNELS
  set x, 0 ; timer of 0 to wait for first rising edge

wait_for_high:
  jmp pin rising_edge
  jmp !x wait_for_high ; wait indefinitely if x is already 0
  jmp x-- nojmp_wait_for_high
nojmp_wait_for_high:
  jmp !x after_sync ; x just reached 0, start a new frame
  jmp wait_for_high

rising_edge:
  jmp !x start_channel ; this was the first rising edge
  jmp !y start_channel ; already reached channel limit or skipping this frame
  in x, 32
  push block
  jmp y-- start_channel
start_channel:
  mov x, osr ; restart channel timer

wait_for_low:
  jmp !x high_pulse_timeout
  jmp pin pin_not_low
  jmp wait_for_high
pin_not_low:
  jmp x-- wait_for_low [2] ; delay to match wait_for_high loop

high_pulse_timeout:
  set x, 0 ; frame error, wait for sync
.wrap


% c-sdk {
static inline void cppm_decoder_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_sm_config c = cppm_decoder_program_get_default_config(offset);

    sm_config_set_jmp_pin(&c, pin);
    pio_gpio_init(pio, pin);
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}
